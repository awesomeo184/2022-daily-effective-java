# 프로그램의 동작을 쓰레드 스케줄러에 기대지 말라

## 부제: thread.setPriority(), Thread.yield()에 기대지 말 것

쓰레드 스케줄링은 기본적으로 운영체제의 몫이다. 따라서 JVM이 온전하게 쓰레드 스케줄링을 관장할 방법은 없다.

쓰레드는 우선순위(priority)라는 멤버 변수를 갖고 있다. 각 쓰레드별로 우선순위를 다르게 설정해줌으로써 어떤 쓰레드에 더 많은 작업 시간을 부여할 것인가를 설정해줄 수 있다.

```java
public class Thread implements Runnable {

    void setPriority(int newPriority);  // 쓰레드의 우선순위를 지정한 값으로 변경한다.

    int getPriority();                  // 쓰레드의 우선순위를 반환한다.


    public static final int MIN_PRIORITY = 1;   // 최소 우선순위

    public static final int NORM_PRIORITY = 5;  // 보통 우선순위

    public static final int MAX_PRIORITY = 10;  // 최대 우선순위

}
```

쓰레드의 우선 순위를 높이면 더 많은 실행 시간과 실행 기회를 부여받을 수 있다. 그런데 주의할 점은 이것이 반드시 보장되는 것이 아니라는 것이다. 
쓰레드의 작업 할당은 OS의 스케쥴링 정책과 JVM의 구현에 따라 다르기 때문에 코드에서 우선순위를 지정하는 것은 단지 희망사항을 전달하는 것일 뿐, 실제 작업은 내가 설정한 우선 순위와 다르게 진행될 수 있다.

따라서 이런 **우선순위에 의존적으로 프로그램을 개발해서는 안된다!** 정확성이나 성능이 쓰레드 스케줄링에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

**가장 좋은 방법은 실행 가능한 쓰레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.**

이 방법을 달성하기 위해서는 쓰레드가 busy waiting 상태가 되도록 설계해서는 안된다.busy waiting이란 처리할 작업이 없는데도 CPU를 점유한채로 대기하는 상태를 말한다.
대체로 아래처럼 임계영역에 진입할 수 있을 때까지 무한루프를 도는 형태로 나타난다.

```java
public void await() {
    while(true) {
        synchronized(this) {
            if (count == 0) return;
        }
    }
}
```


### 정리

쓰레드 우선순위에 의존적인 프로그래밍을 하지 말자! 테스트도 불가능하고, 정확하게 예측하기 어려우며, JVM 버전이 바뀔때마다 달라질 수 있다.

대신에 한 쓰레드가 의미없는 CPU 점유를 하지 않도록 주의해서 실행 가능한 쓰레드 수를 적게 유지하자.